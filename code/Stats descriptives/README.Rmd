---
title: "R Notebook"
output: md_document
---

## Chargement des librairies
```{r}
library(ggplot2)
library(tidyverse)
source("~/suivi-du-data-camp-DeSantiago_Boulahfa_Akrout/code/projet_fct.R")
```

## Chargement et prétraitement de la base de données

Tout d'abord, nous avons filtré la base de données initiale en gardant que les individus ayant un rapport Signal/Noise > 1. Nous voulons, pour l'instant, nous focaliser sur des données qui ne sont pas trop perturbées par le bruit, afin de pouvoir comprendre au mieux la base de données.

```{r}
data_filtered = read.csv("data_filtered.csv")
colnames(data_filtered)[1] <- "Position"
colnames(data_filtered)[2] <- "Covariable"

data_filtered$Covariable = recode_factor(data_filtered$Covariable,"score_structure_boucle"="reactivity")
```

Suite à un changement de nom de la variable reactivity on la renomme à nouveau pour rester cohérent avec les données initiales.

```{r}
data_filtered[1:12,1:8]
```

Chaque colonne (sauf les deux premières) indique les information pour l'individu concerné. Par exemple : ARN 1 nous donne l'information de l'individu du train 1.
De plus, la séquence d'ARN que nous disposons par individu est de longueur 68 (longueur dont nous possédont les labels).

Pour chaque nucléotide de la séquence, nous avons 12 informations :

- Le type de nucléotide, codé avec des entiers tel que : 0="A", 1 = "U", 2 = "C", 3="G".

- Le structure de la boucle.

- Les erreurs de mesures (5).

- Les labels (5).

```{r}
sum(is.na(data_filtered))
```

Ici nous constatons que nous n'avons aucune valeur manquante, donc nous pouvons travailler avec le jeu de données sans avoir à gerer des `NaNs`

```{r}
which(data_filtered[,3+2]<0)
```

On peut apercevoir que pour l'individu n°3 nous avons des valeurs négatives. Ces valeurs sont en fait celles des labels prédit qui sont donc négatives.
Or, les labels quantifient la dégradation des nucléotides donc avoir une valeur négatives implique une résistance à la dégradation, d'où la mise à 0 de ces valeurs. Permettant ainsi d'avoir les lois des labels sur $\mathbb{R}^+$.

```{r}
noms=colnames(data_filtered)[3:1591]
for (i in noms){
  data_filtered[which(data_filtered[,i]<0),i]=0
}
```

## Visualisations :

### Extraction de toutes les nucléotides à toutes les positions.


La séquence ARN étant un enchainement de nucléotides, on suppose fortement que la position de ceux-ci dans la séquence ont une influence sur les labels.
Or, afin d'avoir une première approche de cette base de données, nous allons explorer l'information contenue dedans sans prendre en compte la position des nucléotides, pour le moment.

```{r}
X=extraction_vect(data_filtered,'nucléotide')
Y_reactivity = extraction_vect(data_filtered,'reactivity')
Y_score_mg_ph10 = extraction_vect(data_filtered,'score_mg_ph10')
Y_score_ph10 = extraction_vect(data_filtered,'score_ph10')
Y_score_mg_50c = extraction_vect(data_filtered,'score_mg_50c')
Y_score_50c = extraction_vect(data_filtered,'score_50c')
```

La variable X contient la liste de tous les nucléotides à toutes les positions et pour tout le monde. Les autres variables représentent chacun un label.

```{r}
plot(table(X))
print(table(X))
print(table(X)/sum(table(X)))
```


On constate que nous avons $108052$ nucléotides en tout. Toutefois, on peut voir une plus grande représentation de nucléotides `A` et `G`, comparé aux nucléotides `C` et `U`.
Cette information pourra potentiellement avoir son influence, même si nous avons une quantité assez importante de chaque nucléotide ainsi que les valeurs de labels associés.



